## 前端的发展历史

### 石器时代

- 1990 年，第一个 Web 浏览器诞生了。这是前端这个技术的起点，代表这一年它出生了。后面的时间里，前端圈有很多里程碑事件。
- 1994 年，网景公司发布第一个商业浏览器 Navigator。
- 1995 年，网景工程师 Brendan Eich 用 10 天时间设计了 JavaScript，同年微软发布了 IE 浏览器，进而掀起了浏览器大战。
- 2002 年，IE 在浏览器大战中赢得胜利，IE6 占有率超过 96% 。

随着后端越来越复杂，揉在一起的代码发展出 Model、View 和 Controller，这就是后端 MVC 模式的盛行。

最初，网页还是以数据和简单的特效为主，比如当时众多的门户网站，也都没有太多的用户交互，主要就是显示后端存储的新闻。

直到 2004 年，Google 发布了 Gmail，用户可以在不刷新页面的情况下进行复杂的交互，之后，Ajax 逐渐成为网页开发的技术标准，也不断地被应用于各种网站。**Ajax 这个技术让我们可以异步的获取数据并且刷新页面，从此前端不再受限于后端的模板，这也宣告了 Web2.0 时代正式到来。**

### 铁器时代

在 Gmail 诞生后，依然有浏览器的混战和兼容问题，这个时候 jQuery 出现并迅速风靡全球，**前端开发不再被 JavaScript 的兼容问题困扰。**一个 $ 走天下，学会了 jQuery 就等于学会了前端。

那个时候 jQuery+Bootstrap 一把梭，成为了前端开发领域的主流技术，前端代码内嵌在后端的项目中，写完直接发布。通篇都是如下的代码：

```js
$('#alert-btn').on('click',function(){
  $('#app .input').val('hi')
})
```

那个时候写代码，就是找到某个元素，进行 DOM 操作。随着前端项目规模的逐渐提升，前端也需要规模化的时候，在 2009 年 AngularJS 和 Node.js 的诞生，也宣告前端工业革命的到来。

### 工业时代

AngularJS 的诞生，引领了前端 MVVM 模式的潮流；Node.js 的诞生，让前端有了入侵后端的能力，也加速了前端工程化的诞生。

### 前端的三大框架

在前端 MVVM 模式下，不同框架的目标都是一致的，就是**利用数据驱动页面**，但是怎样处理数据的变化，各个框架走出了不同的路线。

这些框架要回答的核心问题是，**数据发生变化后，我们怎么去通知页面更新。**

Angular1 用最老套的**脏检查**。所谓的脏检查，指的是 **Angular1 对数据变化的检查上，遵循每次用户交互时都检查一次数据是否变化，有变化就去更新 DOM** 这一方法。

后来 Angular 完全抛弃 Angular1，搞了一个全新的框架还叫 Angular，引入 TypeScript、RxJS 等新内容，**但是不支持向前兼容**。

Vue1 的解决方案，就是使用响应式，**初始化的时候，Watcher 监听了数据的每一个属性，这样数据发生变化的时候，我们就能精确地知道数据地哪个 key 变了，去针对性修改对应的 DOM 即可。**

Facebook 的 React 团队设计了 React 框架，在页面初始化的时候，在浏览器 DOM 之上，搞了一个叫**虚拟 DOM** 的东西，也就是**用一个 JavaScript 对象来描述整个 DOM 树**。我们可以很方便地**通过虚拟 DOM 计算出变化的数据，去进行精确的修改。

```react
<div id = "app">
    <p class = "item">Item1</p>
    <div class = "item">Item2</div>
</div>
```

在 React 中，这样一段 HTML 会被映射成一个 JavaScript 的对象进行描述。这个对象就像数据和实际 DOM 的一个缓存层，**通过管理这个对象的变化，来减少对实际 DOM 的操作。**

这种形式不仅让性能有个很好的保障，我们还**多了一个用 JSON 来描述网页的工具，并且让虚拟 DOM 这个技术脱离了 Web 的限制。**因为积累了这么多优势，虚拟 DOM 在小程序，客户端等跨端领域大放异彩。

虚拟 DOM 在运行的时候就是这么一个对象：

```js
{
  tag: "div",
  attrs: {
    id: "app"
  },
  children: [
    {
      tag: "p",
      attrs: { className: "item" },
      children: ["Item1"]
    },
    {
      tag: "div",
      attrs: { className: "item" },
      children: ["Item2"]
    }
  ]
}
```

这个对象完整地描述了 DOM 的树形结构，这样数据有变化的时候，我们生成一份新的虚拟 DOM 数据，然后再对之前的虚拟 DOM 进行计算，算出需要修改的 DOM，再去页面进行操作。

**浏览器操作 DOM 一直都是性能杀手，而虚拟 DOM 的 Diff 的逻辑，又能够确保尽可能少的操作 DOM，这也是虚拟 DOM 驱动的框架性能一直比较优秀的原因之一。**

### Vue 和 React 框架对比

**在 Vue 框架下，如果数据变了，框架会主动告诉你修改了哪些数据**；**而 React 的数据变化后，我们只能通过新老数据的计算 Diff 来得知数据的变化**。

这两种框架都碰到了性能的瓶颈：

- 对于 Vue 来说，它的一个核心就是“响应式”。响应式数据新建 Watcher 监听，本身就比较损耗性能，项目大了之后每个数据都有一个 watcher 会影响性能。
- 对于 React 的虚拟 DOM 的 Diff 计算逻辑来说，如果虚拟 DOM 树过于庞大，使得计算时间大于 16.6 ms， 那么可能会造成性能卡顿。

为了解决这种性能瓶颈，Vue 和 React 走了不同的道路。

- React 为了突破性能瓶颈，借鉴了操作系统时间分片的概念，引入了 **Fiber 架构**。通俗来说，就是把整个虚拟 DOM 树微观化，变成链表，然后我们**利用浏览器的空闲时间计算 Diff**。一旦浏览器有需求，我们可以把没计算完的任务放在一旁，把主进程控制权还给浏览器，等待浏览器下次空闲。

- Vue 1 的问题在于响应式数据过多，这样会带来内存占用过多的问题。所以 Vue 2 大胆引入虚拟 DOM 来解决响应式数据过多的问题。**响应式数据是主动推送变化，虚拟 DOM 是被动计算数据的 Diff，一个推一个拉，它们看起来是两个方向的技术，但被 Vue 2 很好地融合在一起，采用的方式就是组件级别的划分。**对于 Vue 2 来说，组件之间的变化，可以通过响应式来通知更新。组件内部的数据变化，则通过虚拟 DOM 去更新页面。这样就把响应式的监听器，控制在了组件级别，而虚拟 DOM 的量级，也控制在了组件的大小。

除了响应式和虚拟 DOM 这个维度，Vue 和 React 还有一些理念和路线的不同，在模板的书写上，也走出了 template 和 JSX 两个路线。

- React 的世界里只有 JSX，最终 JSX 都会在 Compiler 那一层，也就是工程化那里编译成 JS 来执行，所以 **React 最终拥有了全部 JS 的动态性，这也导致了 React 的 API 一直很少**，只有 state、hooks、Component 几个概念，**主要都是 JavaScript 本身的语法和特性**。

- 而 Vue 的世界默认是 template，也就是语法是限定死的，比如 v-if 和 v-for 等语法。有了这些写法的规矩后，我们可以在上线前做很多优化。Vue 3 很优秀的一个点，就是**在虚拟 DOM 的静态标记上做到了极致，让静态的部分越过虚拟 DOM 的计算，真正做到了按需更新，很好的提高了性能。**

### 思考题

在你看来，**Vue 需不需要 React 的 Fiber 呢**？

**Vue 不需要 React 的 Fiber。**因为 Vue 的虚拟 DOM 的控制在组件级，最早 Vue3 的提案其实是包含时间切片方案的，最后废止的主要原因，时间切片解决的问题，Vue3 基本碰不到：

1. Vue3 把虚拟 DOM 控制在组建级别，组件之间使用响应式，这就让 Vue3 的虚拟 DOM 不会过于庞大；
2. Vue3 虚拟 DOM 的静态标记和自动缓存功能，让静态的节点和属性可以直接绕过 Diff 逻辑，也大大减少了虚拟 DOM 的 Diff 事件；
3. 时间切片也会带来额外的系统复杂性

所以引入时间切片对于 Vue3 来说投入产出比不太理想，在后来的讨论中，Vue3 的时间切片方案就被废弃了。