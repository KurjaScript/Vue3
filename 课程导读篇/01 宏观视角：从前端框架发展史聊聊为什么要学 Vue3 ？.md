## 前端的发展历史

### 石器时代

- 1990 年，第一个 Web 浏览器诞生了。这是前端这个技术的起点，代表这一年它出生了。后面的时间里，前端圈有很多里程碑事件。
- 1994 年，网景公司发布第一个商业浏览器 Navigator。
- 1995 年，网景工程师 Brendan Eich 用 10 天时间设计了 JavaScript，同年微软发布了 IE 浏览器，进而掀起了浏览器大战。
- 2002 年，IE 在浏览器大战中赢得胜利，IE6 占有率超过 96% 。

随着后端越来越复杂，揉在一起的代码发展出 Model、View 和 Controller，这就是后端 MVC 模式的盛行。

最初，网页还是以数据和简单的特效为主，比如当时众多的门户网站，也都没有太多的用户交互，主要就是显示后端存储的新闻。

直到 2004 年，Google 发布了 Gmail，用户可以在不刷新页面的情况下进行复杂的交互，之后，Ajax 逐渐成为网页开发的技术标准，也不断地被应用于各种网站。**Ajax 这个技术让我们可以异步的获取数据并且刷新页面，从此前端不再受限于后端的模板，这也宣告了 Web2.0 时代正式到来。**

### 铁器时代

在 Gmail 诞生后，依然有浏览器的混战和兼容问题，这个时候 jQuery 出现并迅速风靡全球，**前端开发不再被 JavaScript 的兼容问题困扰。**一个 $ 走天下，学会了 jQuery 就等于学会了前端。

那个时候 jQuery+Bootstrap 一把梭，成为了前端开发领域的主流技术，前端代码内嵌在后端的项目中，写完直接发布。通篇都是如下的代码：

```js
$('#alert-btn').on('click',function(){
  $('#app .input').val('hi')
})
```

那个时候写代码，就是找到某个元素，进行 DOM 操作。随着前端项目规模的逐渐提升，前端也需要规模化的时候，在 2009 年 AngularJS 和 Node.js 的诞生，也宣告前端工业革命的到来。

### 工业时代

AngularJS 的诞生，引领了前端 MVVM 模式的潮流；Node.js 的诞生，让前端有了入侵后端的能力，也加速了前端工程化的诞生。

### 前端的三大框架

在前端 MVVM 模式下，不同框架的目标都是一致的，就是**利用数据驱动页面**，但是怎样处理数据的变化，各个框架走出了不同的路线。

这些框架要回答的核心问题是，**数据发生变化后，我们怎么去通知页面更新。**

Angular1 用最老套的**脏检查**。所谓的脏检查，指的是 **Angular1 对数据变化的检查上，遵循每次用户交互时都检查一次数据是否变化，有变化就去更新 DOM** 这一方法。

后来 Angular 完全抛弃 Angular1，搞了一个全新的框架还叫 Angular，引入 TypeScript、RxJS 等新内容，**但是不支持向前兼容**。

Vue1 的解决方案，就是使用响应式，**初始化的时候，Watcher 监听了数据的每一个属性，这样数据发生变化的时候，我们就能精确地知道数据地哪个 key 变了，去针对性修改对应的 DOM 即可。**

Facebook 的 React 团队设计了 React 框架，在页面初始化的时候，在浏览器 DOM 之上，搞了一个叫**虚拟 DOM** 的东西，也就是**用一个 JavaScript 对象来描述整个 DOM 树**。我们可以很方便地**通过虚拟 DOM 计算出变化的数据，去进行精确的修改。

```react
<div id = "app">
    <p class = "item">Item1</p>
    <div class = "item">Item2</div>
</div>
```

在 React 中，这样一段 HTML 会被映射成一个 JavaScript 的对象进行描述。这个对象就像数据和实际 DOM 的一个缓存层，**通过管理这个对象的变化，来减少对实际 DOM 的操作。**

这种形式不仅让性能有个很好的保障，我们还**多了一个用 JSON 来描述网页的工具，并且让虚拟 DOM 这个技术脱离了 Web 的限制。**因为积累了这么多优势，虚拟 DOM 在小程序，客户端等跨端领域大放异彩。

虚拟 DOM 在运行的时候就是这么一个对象：

```js
{
  tag: "div",
  attrs: {
    id: "app"
  },
  children: [
    {
      tag: "p",
      attrs: { className: "item" },
      children: ["Item1"]
    },
    {
      tag: "div",
      attrs: { className: "item" },
      children: ["Item2"]
    }
  ]
}
```

这个对象完整地描述了 DOM 的树形结构，这样数据有变化的时候，我们生成一份新的虚拟 DOM 数据，然后再对之前的虚拟 DOM 进行计算，算出需要修改的 DOM，再去页面进行操作。

**浏览器操作 DOM 一直都是性能杀手，而虚拟 DOM 的 Diff 的逻辑，又能够确保尽可能少的操作 DOM，这也是虚拟 DOM 驱动的框架性能一直比较优秀的原因之一。**

### 